package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

func newMakeTemplates(opts ...MakeOption) *makeTemplates {
	mapped := make(map[string]string)
	m := &makeTemplates{mapped: mapped}
	// Process functions
	m.processors = []makeProcessFunc{
		m.processPrefix,
		m.processPackage,
		m.processAutogenerated,
	}
	// Apply opts
	for _, opt := range opts {
		opt(m)
	}
	return m
}

type makeTemplates struct {
	prefix     string
	processors []makeProcessFunc
	mapped     map[string]string // A collection of keys made
}

func (m *makeTemplates) Run(srcs map[string]string) error {
	for k, v := range srcs {
		m.runSrc(k, v)
	}
	return nil
}

func (m *makeTemplates) runSrc(name string, content string) error {
	fmt.Println("make", name)
	ic := newMakeContent(name, content)
	for _, fn := range m.processors {
		err := fn(ic)
		if err != nil {
			return err
		}
	}
	ic.b.Reset()
	for _, line := range ic.lines {
		ic.b.WriteString(line)
		ic.b.WriteString("\n")
	}
	path := filepath.Join("data", name+".txt")
	data := []byte(ic.b.String())
	fmt.Println("write", path)
	return os.WriteFile(path, data, 0644)
}

func (m *makeTemplates) processPrefix(c *makeContent) error {
	if m.prefix == "" {
		return nil
	}
	for i, line := range c.lines {
		c.lines[i] = strings.ReplaceAll(line, m.prefix, prefixKey)
	}
	//	c := pin.Content
	//	for i := strings.Index(c, n.prefix); i >= 0; i = strings.Index(c, n.prefix) {
	//		fmt.Println("prefix at", i)
	//	}
	//	c = strings.ReplaceAll(c, n.prefix, prefixKey)
	m.mapped[prefixKey] = ""
	//	pin.Content = c
	return nil
}

func (m *makeTemplates) processPackage(c *makeContent) error {
	const prefix string = "package "
	for i, line := range c.lines {
		if strings.HasPrefix(line, prefix) {
			c.lines[i] = prefix + packageKey
			m.mapped[packageKey] = ""
			return nil
		}
	}
	return fmt.Errorf("no package line")
}

func (m *makeTemplates) processAutogenerated(c *makeContent) error {
	const prefix string = `// autogenerated with `
	const line0 string = ""
	const line1 string = prefix + toxPackageKey
	const line2 string = `// do not modify`
	for i, line := range c.lines {
		if strings.HasPrefix(line, prefix) {
			c.lines[i] = line1
			return nil
		}
	}

	if len(c.lines) < 2 {
		c.lines = append(c.lines, []string{line0, line1, line2}...)
	} else {
		c.lines = slices.Insert(c.lines, 1, line0, line1, line2)
	}
	m.mapped[toxPackageKey] = ""
	return nil
}

type makeProcessFunc func(c *makeContent) error

type makeContent struct {
	b     strings.Builder
	name  string
	lines []string
}

func newMakeContent(name, content string) *makeContent {
	ic := &makeContent{name: name}
	ic.b.Grow(len(content) * 2)
	scanner := bufio.NewScanner(strings.NewReader(content))
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		ic.lines = append(ic.lines, scanner.Text())
	}
	return ic
}

// getLines answers the first n lines in s.
func getLines(s string, n int) []string {
	var lines []string
	for i := 0; i < n; i++ {
	}
	return lines
}

func replaceExt(s, newExt string) string {
	ext := filepath.Ext(s)
	return s[0:len(s)-len(ext)] + "." + newExt
}

const (
	prefixKey     = "{{.prefix}}"
	packageKey    = "{{.package}}"
	toxPackageKey = "{{.toxPackage}}"
)
