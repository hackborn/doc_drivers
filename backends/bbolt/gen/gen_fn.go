package bboltgendriver

// autogenerated with github.com/hackborn/doc_drivers
// do not modify

import (
	"encoding/binary"
	"fmt"

	"github.com/hackborn/doc"
)

// genNewFormat answers a new Format for the driver,
// containing the formatting rules for translating
// expressions.
func genNewFormat() doc.Format {
	keywords := map[string]string{
		doc.AndKeyword:    " AND ",
		doc.AssignKeyword: " = ",
		doc.OrKeyword:     " OR ",
	}
	return &genFormat{keywords: keywords}
}

type genFormat struct {
	keywords map[string]string
}

func (f *genFormat) Keyword(s string) string {
	s, _ = f.keywords[s]
	return s
}

func (f *genFormat) Value(v interface{}) (string, error) {
	s := fmt.Sprintf("%v", v)
	switch v.(type) {
	case string:
		c := string('\'')
		s = c + s + c
	}
	return s, nil
}

// genToBoltKey converts values into []byte values used as bolt keys.
func genToBoltKey(value any, ft fieldType) (boltKey, bool) {
	// The expression parsing doesn't know the type of the
	// values, so make sure they match.
	if ft == stringType {
		if _, ok := value.(string); !ok {
			value = fmt.Sprintf("%v", value)
		}
	}

	switch t := value.(type) {
	case uint64:
		return genItob(t), true
	case string:
		return []byte(t), true
	}
	return nil, false
}

// genItob returns an 8-byte big endian representation of v.
func genItob(v uint64) []byte {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, v)
	return b
}
