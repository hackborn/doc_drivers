package bboltgendriver

// autogenerated with github.com/hackborn/doc_drivers
// do not modify

import (
	"encoding/binary"
	"fmt"

	"github.com/hackborn/doc"
)

// genNewFormat answers a new Format for the driver,
// containing the formatting rules for translating
// expressions.
func genNewFormat() doc.Format {
	keywords := map[string]string{
		doc.AndKeyword:    " AND ",
		doc.AssignKeyword: " = ",
		doc.OrKeyword:     " OR ",
	}
	return &genFormat{keywords: keywords}
}

type genFormat struct {
	keywords map[string]string
}

func (f *genFormat) Keyword(s string) string {
	s, _ = f.keywords[s]
	return s
}

func (f *genFormat) Value(v interface{}) (string, error) {
	s := fmt.Sprintf("%v", v)
	switch v.(type) {
	case string:
		c := string('\'')
		s = c + s + c
	}
	return s, nil
}

// genItob returns an 8-byte big endian representation of v.
func genItob(v uint64) []byte {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, v)
	return b
}

func newGetBucketValuesHandler(rootBucket string, buckets []genKeyMetadata) *getBucketValuesHandler {
	values := make([]string, len(buckets)+1)
	values[0] = rootBucket
	return &getBucketValuesHandler{buckets: buckets,
		values: values,
	}
}

type getBucketValuesHandler struct {
	buckets []genKeyMetadata
	// Values is all the values in the buckets, with the 0 value set to
	// the root bucket, so the size will be len(buckets)+1.
	values []string
}

// makeKey combines the values into a single key, reporting an
// error if anyone is missing.
func (h *getBucketValuesHandler) makeKey() (string, bool, error) {
	key := ""
	for i, s := range h.values {
		if s == "" {
			return "", false, fmt.Errorf("Missing value for %v", h.buckets[i-1].domainName)
		}
		if i > 0 {
			key += "/"
		}
		key += s
		// If this is a leaf, just use the leaf
		if i > 0 && h.buckets[i-1].leaf {
			fmt.Println("LEAF for", h.values, h.buckets[i-1], s)
			autoinc := false
			if h.buckets[i-1].autoInc == true {
				autoinc = true
			}
			return s, autoinc, nil
		}
	}
	return key, false, nil
}

func (h *getBucketValuesHandler) Handle(name string, value any) (string, any) {
	for i, b := range h.buckets {
		if b.domainName == name {
			if s, ok := value.(string); ok {
				// +1 skips the root bucket
				h.values[i+1] = s
			}
		}
	}
	return "", nil
}
