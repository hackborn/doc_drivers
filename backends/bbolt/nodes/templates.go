package nodes

import (
	"bufio"
	"cmp"
	"fmt"
	"slices"
	"strings"

	"github.com/hackborn/doc_drivers/registry"
	"github.com/hackborn/onefunc/pipeline"
)

type templateSettings struct {
	fromPrefix, toPrefix string
	pkg                  string
}

func makeTemplates(settings templateSettings) (map[string]string, error) {
	mk := &mktmplate{settings: settings}
	return mk.run()
}

type mktmplate struct {
	settings templateSettings
	err      error
}

func (n *mktmplate) run() (map[string]string, error) {
	files, err := n.load()
	if err != nil {
		return nil, err
	}
	b := &strings.Builder{}
	for k, v := range files {
		c := newTemplateContent(k, v)
		b.Reset()
		c.b = b
		n.err = cmp.Or(n.err, n.processPackage(c))
		n.err = cmp.Or(n.err, n.processPrefix(c))
		n.err = cmp.Or(n.err, n.processAutogenerated(c))
		n.err = cmp.Or(n.err, n.processBody(c))
		files[k] = c.compile()
	}
	return files, n.err
}

func (n *mktmplate) load() (map[string]string, error) {
	// Load reference files
	expr := `graph (load(Fs="bboltref", Glob="ref/ref_*.go") )`
	out, err := pipeline.RunExpr(expr, nil, nil)
	if err != nil || out == nil {
		return nil, cmp.Or(err, fmt.Errorf("could not load reference files"))
	}
	t := make(map[string]string)
	for _, pin := range out.Pins {
		if d, ok := pin.Payload.(*pipeline.ContentData); ok {
			key := strings.TrimPrefix(d.Name, "ref_")
			key = strings.TrimSuffix(key, ".go")
			t[key] = d.Data
		}
	}
	return t, nil
}

func (n *mktmplate) processPackage(c *templateContent) error {
	const prefix string = "package "
	for i, line := range c.lines {
		if strings.HasPrefix(line, prefix) {
			c.lines[i] = prefix + n.settings.pkg
			return nil
		}
	}
	return fmt.Errorf("no package line")
}

func (n *mktmplate) processPrefix(c *templateContent) error {
	if n.settings.toPrefix == "" {
		return nil
	}
	if n.settings.fromPrefix == "" {
		return fmt.Errorf("Missing fromPrefix")
	}
	for i, line := range c.lines {
		c.lines[i] = strings.ReplaceAll(line, n.settings.fromPrefix, n.settings.toPrefix)
	}
	return nil
}

func (n *mktmplate) processAutogenerated(c *templateContent) error {
	const prefix string = `// autogenerated with `
	const line0 string = ""
	line1 := prefix + registry.UtilPackageName
	const line2 string = `// do not modify`
	for i, line := range c.lines {
		if strings.HasPrefix(line, prefix) {
			c.lines[i] = line1
			return nil
		}
	}

	if len(c.lines) < 2 {
		c.lines = append(c.lines, []string{line0, line1, line2}...)
	} else {
		c.lines = slices.Insert(c.lines, 1, line0, line1, line2)
	}
	return nil
}

func (n *mktmplate) processBody(c *templateContent) error {
	switch c.name {
	case "json":
		return n.processBodyJson(c)
	case "const":
		return n.processBodyMetadata(c)
	}
	return nil
}

func (n *mktmplate) processBodyJson(c *templateContent) error {
	s, e, ok := c.findRange(beginJson, endJson)
	if !ok {
		return fmt.Errorf("file \"" + c.name + "\" is missing json comment")
	}
	lines := c.lines[:s]
	lines = append(lines, jsonDefs)
	lines = append(lines, c.lines[e+1:]...)
	c.lines = lines
	return nil
}

func (n *mktmplate) processBodyMetadata(c *templateContent) error {
	s, e, ok := c.findRange(beginMetadata, endMetadata)
	if !ok {
		return fmt.Errorf("file \"" + c.name + "\" is missing metadata comment")
	}
	lines := c.lines[:s]
	lines = append(lines, metadataDefs)
	lines = append(lines, c.lines[e+1:]...)
	c.lines = lines
	return nil
}

// ---------------------------------------------------------
// TEMPLATE-CONTENT

func newTemplateContent(name, content string) *templateContent {
	c := &templateContent{name: name}
	scanner := bufio.NewScanner(strings.NewReader(content))
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		c.lines = append(c.lines, scanner.Text())
	}
	return c
}

type templateContent struct {
	name  string
	b     *strings.Builder
	lines []string
}

func (c *templateContent) findRange(start, end string) (int, int, bool) {
	sp := -1
	ep := -1
	for i, s := range c.lines {
		if strings.Index(s, start) >= 0 {
			sp = i
		}
		if strings.Index(s, end) >= 0 {
			ep = i
		}
		if sp >= 0 && ep >= 0 {
			return sp, ep, true
		}
	}
	return -1, -1, false
}

func (c *templateContent) compile() string {
	c.b.Reset()
	for _, line := range c.lines {
		c.b.WriteString(line)
		c.b.WriteString("\n")
	}
	return c.b.String()
}

// ---------------------------------------------------------
// TEMPLATE-CONTENT

const (
	beginJson = `// Begin json`
	endJson   = `// End json`
	jsonDefs  = "{{range .Json}}\n" +
		"type {{.Name}} struct {\n" +
		"{{range .Fields}}" +
		"\t{{.Name}}\t{{.Type}}\t{{.Tag}}\n" +
		"{{end}}" +
		"}\n{{end}}"
	beginMetadata = `// Begin metadata`
	endMetadata   = `// End metadata`
	metadataDefs  = "{{range .Metadata}}\n" +
		"		`{{.DomainName}}`: {\n" +
		"			rootBucket: \"{{.RootBucket}}\",\n" +
		"			buckets: []{{$.Prefix}}KeyMetadata{\n" +
		"{{range .Buckets}}" +
		"				{domainName: \"{{.DomainName}}\", boltName: \"{{.BoltName}}\", ft: {{.Ft}}, leaf: {{.Leaf}}, autoInc: {{.AutoInc}}},\n" +
		"{{end}}" +
		"			},\n" +
		"			newConvStruct: func() any { return &{{.NewConvStruct}}{} },\n" +
		"		},{{end}}"
)
