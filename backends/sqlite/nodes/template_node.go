package nodes

import (
	"fmt"
	"slices"
	"strings"

	"github.com/hackborn/onefunc/errors"
	"github.com/hackborn/onefunc/pipeline"
)

func newTemplateNode() pipeline.Node {
	mapped := make(map[string]string)
	n := &templateNode{mapped: mapped}
	// Process functions
	n.processors = []makeTemplateContentFunc{
		n.processPrefix,
		n.processPackage,
		n.processAutogenerated,
	}
	return n
}

type templateNode struct {
	Prefix string

	processors []makeTemplateContentFunc

	// A collection of keys made by the processors.
	mapped map[string]string
}

func (n *templateNode) Run(state *pipeline.State, input pipeline.RunInput) (*pipeline.RunOutput, error) {
	output := &pipeline.RunOutput{}
	eb := &errors.FirstBlock{}
	fmt.Println("template in pins", len(input.Pins))
	for _, pin := range input.Pins {
		switch p := pin.Payload.(type) {
		case *pipeline.ContentData:
			eb.AddError(n.runContentPin(p, output))
		}
	}
	fmt.Println("template out pins", len(output.Pins))
	for _, pin := range output.Pins {
		fmt.Println("pin", pin.Name)
		switch p := pin.Payload.(type) {
		case *pipeline.ContentData:
			fmt.Println("\tname", p.Name, "format", p.Format)
		default:
			fmt.Println("\tuknown type")
		}
	}
	return output, eb.Err
}

func (n *templateNode) runContentPin(pin *pipeline.ContentData, output *pipeline.RunOutput) error {
	// XXX ideally everything is hooked up enough to check the format is "go"
	if pin.Name == "" {
		return fmt.Errorf("template node: missing pin name")
	}
	ic := newMakeTemplateContent(pin.Name, pin.Data)
	for _, fn := range n.processors {
		err := fn(ic)
		if err != nil {
			return err
		}
	}
	ic.b.Reset()
	for _, line := range ic.Lines {
		ic.b.WriteString(line)
		ic.b.WriteString("\n")
	}
	outpin := &pipeline.ContentData{Name: pin.Name + ".txt", Data: ic.b.String(), Format: "txt"}
	output.Pins = append(output.Pins, pipeline.Pin{Payload: outpin})
	return nil
}

func (n *templateNode) processPrefix(c *makeTemplateContent) error {
	if n.Prefix == "" {
		return nil
	}
	for i, line := range c.Lines {
		c.Lines[i] = strings.ReplaceAll(line, n.Prefix, templatePrefixKey)
	}
	n.mapped[templatePrefixKey] = ""
	return nil
}

func (n *templateNode) processPackage(c *makeTemplateContent) error {
	const prefix string = "package "
	for i, line := range c.Lines {
		if strings.HasPrefix(line, prefix) {
			c.Lines[i] = prefix + templatePackageKey
			n.mapped[templatePackageKey] = ""
			return nil
		}
	}
	return fmt.Errorf("no package line")
}

func (n *templateNode) processAutogenerated(c *makeTemplateContent) error {
	const prefix string = `// autogenerated with `
	const line0 string = ""
	const line1 string = prefix + templateToxPackageKey + " on " + templateDatestampKey
	const line2 string = `// do not modify`
	for i, line := range c.Lines {
		if strings.HasPrefix(line, prefix) {
			c.Lines[i] = line1
			return nil
		}
	}

	if len(c.Lines) < 2 {
		c.Lines = append(c.Lines, []string{line0, line1, line2}...)
	} else {
		c.Lines = slices.Insert(c.Lines, 1, line0, line1, line2)
	}
	n.mapped[templateToxPackageKey] = ""
	n.mapped[templateDatestampKey] = ""
	return nil
}
